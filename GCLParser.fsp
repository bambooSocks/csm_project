// Open the file that defines the type "expr" we shall use as AST
%{
open GCLTypesAST
%}

// Declare the tokens (terminal symbols)
%token <int> NUM
%token IF FI DO OD ASSIGN VAR CMDSEQ ARROW GCSEQ LBRAC RBRAC
       SKIP TRUE FALSE SHORTAND SHORTOR AND OR NEQ GTE LTE 
       NOT EQ LT GT MUL DIV PLUS MINUS POW LPAR RPAR EOF
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)

//specify precedence and associativity of operator for BEXp
%left SHORTOR OR 
%left SHORTAND AND
%right NOT

//specify precedence and associativity of operator for AExp
%left PLUS MINUS
%left MUL DIV
%left POW

//specify precedence and associativity of operator for CExp
%right ASSIGN
%right SKIP 
%right CMDSEQ 
%right IF FI
%right DO OD 

//specify precedence and associativity of operator for GCExp

%right ARROW


// We declare the initial non-terminal symbol
%start start

// We specify the return type of each of then non-terminal symbols
%type <expr> start
%type <expr> aexp
%type <expr> bexp
%type <expr> cmd
%type <expr> g_cmd

// Grammar productions
%%

// The first production in "formal" notation is
// start -> expression
// here written:
start: cmd EOF             { $1 }

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:
aexp:
  | NUM                             { Num($1) }
  | VAR                             { Var($1) }
  | VAR LBRAC aexp RBRAC            { Array($1, $3) }
  | aexp MUL aexp                   { Mul($1, $3) }
  | aexp DIV aexp                   { Div($1, $3) }
  | aexp PLUS aexp                  { Plus($1, $3) }
  | aexp MINUS aexp                 { Minus($1, $3) }
  | MINUS aexp                      { UnaryMinus($2) }
  | aexp POW aexp                   { Pow($1, $3) }
  | LPAR aexp RPAR                  { $2 }

bexp:
  | TRUE                            { TExp }
  | FALSE                           { FExp }
  | bexp SHORTAND bexp              { ShortAndExp($1, $3) }
  | bexp SHORTOR bexp               { ShortOrExp($1, $3) }
  | bexp AND bexp                   { AndExp($1, $3) }
  | bexp OR bexp                    { OrExp($1, $3) }
  | NOT bexp                        { NotExp($2) }
  | aexp EQ aexp                    { EqExp($1, $3) }
  | aexp NEQ aexp                   { NotEqExp($1, $3) }
  | aexp GT aexp                    { GreaterExp($1, $3) }
  | aexp LT aexp                    { LessExp($1, $3) }
  | aexp GTE aexp                   { GreaterEqExp($1, $3) }
  | aexp LTE aexp                   { LessEqExp($1, $3) }
  | LPAR bexp RPAR                  { $2 }

cmd:
  | VAR ASSIGN aexp                     { Assignment($1, $3) }
  | VAR LBRAC aezp RBRAC ASSIGN aexp    { ArrayAssignment($1, $3, $6) }
  | SKIP                                { SkipExp }
  | cmd CMDSEQ cmd                      { CExpSeq($1, $3) }
  | IF g_cmd FI                         { IfExp($2) }
  | DO g_cmd OD                         { DoExp($2) }

g_cmd:
  | bexp ARROW cmd                      { GC($1, $3) }
  | g_cmd GCSEQ g_cmd                   { GCSeq($1, $3) }

%%